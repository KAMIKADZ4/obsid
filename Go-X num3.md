**Содержание**
1. Массивы
	- Объявление массива
	- Работа с массивом
		- Доступ
		- Копирование
		- Длина и вместимость
		- Итерирование
1. Срезы
	- Создание
	- Работа со срезом
		- Доступ
		- Добавление
		- Копирование
		- Срез
		- Итерирование
	- Увеличение емкости срезов
	- Примечание по срезам
# Массивы

Массивы в Go это фиксированная последовательность элементов одного типа
Размер массива необходимо задавать на этапе компиляции, это может быть как явное указание, так и через константу
Размер массива входит в определение типа
```go
const size = 10

var elems [5]int
var numbers [size]bool
```
Переменная массива обозначает весь массив; это не указатель на первый элемент массива (как в случае C). Это означает, что когда вы присваиваете или передаете значение массива, вы создаете копию его содержимого.

## Объявление массива

```go
var arr [5]int
// В arr будет [0 0 0 0 0]
arr = [5]int{2, 4, 6, 8, 10}
// теперь в arr [2 4 6 8 10]


arr2 := [3]int{3, 6, 9}
```
Так же если не указывать размер массива, но задать значения, то компилятор сам определит размер
```go
arr := [...]int{1, 2, 3, 4} // Массив из 4 элементов
```

## Работа с массивом

**Доступ** осуществляется по индексу, попытка получения доступа по несуществующему индексу приведет к ошибки во время компиляции или панику во время выполнения
```go
arr := [3]int{10, 20, 30}
fmt.Println(arr[0]) // 10
fmt.Println(arr[3]) // 30
fmt.Println(arr[7]) // ошибка во время компиляции
fmt.Println(arr[n]) // пусть значение n задаётся пользовательским вводом, и значение превысит размер массива, то будет паника
```

**Копирование** массивов происходит при присваивании одного массива другому, то в Go они являются значениями, а не ссылками.
```go
arr1 := [3]int{1, 2, 3}
arr2 := arr1 // arr2 — это копия arr1
arr2[0] = 100
fmt.Println(arr1) // [1, 2, 3]
fmt.Println(arr2) // [100, 2, 3]
fmt.Printf("arr1 addr: %p\n", &arr1) // arr1 addr: 0xc0000b0000
fmt.Printf("arr2 addr: %p\n", &arr2) // arr2 addr: 0xc0000b0018
```
Для простоты понимания можно представить массив как структуру из N-ого набора атрибутов
```go
arr := [3]int{1, 2, 3}
// можно грубо представить как 
type arr struct {
	i0 int
	i1 int
	i2 int
}

// зато можно  передать ссылку
x := [3]int{1, 2, 3}
z := &x
x[0] = 10
z[1] = 20
fmt.Println(x, z) // [10 20 3] [10 20 3]
```

**Длина и вместимость** массива всегда будет выдавать одно и тоже значение
```go
var x [3]int
fmt.Println(cap(x), len(x)) // 3 3
```

**Итерирование по массиву**
Для итерирования по массиву можно использовать цикл `for
```go
arr := [3]string{"a", "b", "c"}
for i := 0; i < len(arr); i++ {
	fmt.Println(arr[i])
}
```

Или использовать `for range`
```go
for index, value := range arr {
    fmt.Println(index, value)
}
```
В 1ую переменную (в данном случае `index`) помещается индекс элемента, во 2ую переменную (в данном случае `value`) помещается значение элемента
Либо 1ую, либо 2ую переменную можно заменить на `_` если вам не нужно её использование 
# Срезы

в Go срезы являются структурой данных, которая представляет из себя динамический массив. То есть по мере добавления объектов в массив он может увеличиваться в процессе выполнения программы.
Срез можно представить такой структурой
```go
type slice struct {
	len int
	cap int
	addr uintptr
}
```

## Создание среза

```go
// Создание среза из массива
arr := [5]int{1, 2, 3, 4, 5}
slice := arr[1:4] // slice = [2, 3, 4], длина = 3, емкость = 4

// Создание среза с помощью make
// func make([]T, len, cap) []T
slice2 := make([]int, 3, 5) // slice2 = [0, 0, 0], длина = 3, емкость = 5

// Создание среза с инициализацией
slice3 := []int{1, 2, 3} // slice3 = [1, 2, 3], длина = 3, емкость = 3
```
Если у функции `make` НЕ указан параметр `cap`, то будет использовано в качества емкости значение в `len`
## Работа со срезом

**Доступ** осуществляется так же как и в массивах - по индексу.
```go
slice := []int{9, 8, 7}
slice[0] // 9
slice[1] // 8
slice[2] // 7
```

**Добавление** элементов осуществляется с помощью функции `append`
```go
slice := []int{1, 2, 3}
slice = append(slice, 4) // slice = [1, 2, 3, 4]
slice = append(slice, 5, 6, 7) // slice = [1, 2, 3, 4, 5, 6, 7]
```

**Копирование** срезов осуществляется с помощью функции `copy`
```go
src := []int{1, 2, 3}

// если размеры срезов равны
dst := make([]int, len(src))
copy(dst, src) // dst = [1, 2, 3]

// если новый срез меньше
dst := make([]int, len(src) - 1)
copy(dst, src) // dst = [1, 2]

// если новый срез больше
dst := make([]int, len(src) + 2)
copy(dst, src) // dst = [1, 2, 3, 0, 0]
```
Копирование как при массивах не сработает, так как срезы будут указывать на одинаковый сегмент памяти
```go
func main() {
	y := make([]int, 1, 3)
	_ = append(y, 1)
	fmt.Println(y)

	arr1 := []int{1, 2, 3}
	arr2 := arr1
	arr2[0] = 10 
	fmt.Println(arr1, arr2) // [10 2 3] [10 2 3]
	fmt.Printf("arr1 addr: %p\n", &arr1) // arr1 addr: 0xc000128000
	fmt.Printf("arr2 addr: %p\n", &arr2) // arr2 addr: 0xc000128018

	fmt.Printf("arr1[0] addr: %p\n", &arr1[0]) // arr1[0] addr: 0xc00012a000
	fmt.Printf("arr2[0] addr: %p\n", &arr2[0]) // arr2[0] addr: 0xc00012a000
}
```

**Срез** по индексам можно снова осуществить как для массивов, так идля срезов
```go
arr := [5]int{2, 4, 6, 8, 10}
slice := slice[1:3] // slice = [4, 6], длина = 2, емкость = 4

slice = []int{1, 2, 3, 4, 5}
slice = slice[:3] // slice = [1, 2, 3], длина = 3, емкость = 5
```

**Итерация** по срезу аналогична как и для массивов (`for` или `for range`)
```go
arr := [3]string{"a", "b", "c"}
for i := 0; i < len(arr); i++ {
	fmt.Println(i, arr[i])
}

for index, value := range arr {
    fmt.Println(index, value)
}
```

## Увеличение емкости срезов

В момент когда добавляется в срез элементы, то проверятся что размер среза с учетом добавленных элементов меньше или равен емкости, в случае если это не так, то происходит увеличение емкости среза. Сначала выбирается новая емкость для среза, из старого сегмента элементы копируются в новый, добавляются новые элементы.

История работы со срезами в Go достаточно интересная тема
- до 1.18 
	Срезы размером до 1024 увеличивались в 2 раза, далее в 1.25 раз
- в 1.18
	Срезы размеров до 256 увеличиваются в 2 раза, далее по формуле `newcap += (newcap + 3*threshold) / 4`, где `threshold` = 256
- в 1.23
	Срезы размеров до 256 увеличиваются в 2 раза, далее по формуле `newcap += (newcap + 3*threshold) >> 2`, где `threshold` = 256, по сути та же формула, что и в 1.18, но деление производительнее
https://habr.com/ru/articles/660827/ изменение в росте среза с новой версией

Что позволяет новая формула? Чем больше массив, тем меньше коэффициент увеличения среза
Пример, который это доказывает
```go
package main

import (
	"fmt"
)

// скопирует внутренюю функции GO 
func nextslicecap(newLen, oldCap int) int {
	newcap := oldCap
	doublecap := newcap + newcap
	if newLen > doublecap {
		return newLen
	}
	const threshold = 256
	if oldCap < threshold {
		return doublecap
	}
	for {
		// Transition from growing 2x for small slices
		// to growing 1.25x for large slices. This formula
		// gives a smooth-ish transition between the two.
		newcap += (newcap + 3*threshold) >> 2
		// We need to check `newcap >= newLen` and whether `newcap` overflowed.
		// newLen is guaranteed to be larger than zero, hence
		// when newcap overflows then `uint(newcap) > uint(newLen)`.
		// This allows to check for both with the same comparison.
		if uint(newcap) >= uint(newLen) {
			break
		}
	}
	// Set newcap to the requested cap when
	// the newcap calculation overflowed.
	if newcap <= 0 {
		return newLen
	}
	return newcap
}

func main() {
	for _, val := range []int{257, 260, 400, 512, 800, 1024, 2000, 5000, 10000} {
		dep := (v + 3*256) >> 2 // на сколько увечивать val
		fmt.Println(val, dep, float64(dep) / float64(val))
	}
}
// Вывод
/*
257 256 0.9961089494163424
260 257 0.9884615384615385
400 292 0.73
512 320 0.625
800 392 0.49
1024 448 0.4375
2000 692 0.346
5000 1442 0.2884
10000 2692 0.2692
*/
```

https://go.googlesource.com/go/+/refs/tags/go1.23.5/src/runtime/slice.go Ссылка на исходники Go
в строке **289** функция `nextslicecap`, которая отвечает за выбор новой емкости среза
в строке **209** после вызова `nextslicecap` по моим предположениям происходит какая то оптимизация размера. Подтверждается этим кодом:
```go


func main() {
	for _, v := range []int{257, 260, 400, 512, 800, 1024, 2000, 5000, 10000} {
		dep := (v + 3*256) >> 2 // на сколько увечи
		fmt.Println(v, nextslicecap(v+1, v), cap(append(make([]int, v), 1)))
	}
}
// Вывод
/*
257 513 608
260 517 608
400 692 768
512 832 848
800 1192 1216
1024 1472 1536
2000 2692 2720
5000 6442 7168
10000 12692 13312
*/
```

## Примечания по срезам

При работе со срезами важно понимать как они работают, что бы избежать ошибок
Разберем случай создания среза из массива
```go
arr := [7]int{2, 4, 6, 8, 10, 12, 14} // длина = 7, емкость = 7
slice := arr[2:6] // длина = 4, емкость = 6
fmt.Println(slice) // [6 8 10 12]
```
Откуда же появилась емкость `6` у среза, который мы только что создали? Поскольку для массива выделился сегмент памяти длиной 7 и поэтому срез, созданный по этому массиву тоже ссылается на этот сегмент памяти. Емкость 6, а не 7, так как в срез не вошло первое числи массива.

Получается, при "перенарезке" среза или создании среда от массива, то срез всё равно указывает на исходный сегмент памяти. В каких случаях это может навредить?
Например мы читаем файл и получаем срез, удовлетворяющему нашему регулярному выражению. 
```go
var digitRegexp = regexp.MustCompile("[0-9]+")

func FindDigits(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    return digitRegexp.Find(b)
}
```
В этом коде возвращенный срез байт (`[]byte`) указывает на массив, содержащий весь файл. Поскольку срез ссылается на оригинальный массив, то сборщик мусора не может освободить массив

Пример решения проблемы выше
```go
func CopyDigits(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    b = digitRegexp.Find(b)
    c := make([]byte, len(b))
    copy(c, b)
    return c
}
```

https://go.dev/blog/slices-intro Статья про работу срезов
