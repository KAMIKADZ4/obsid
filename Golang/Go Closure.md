Замыкания(closure) в Go - это функции, которые ссылаются на переменные вне своего тела. То есть функция эти функции "запоминает" или "захватывают" переменные из области видимости , где была определена функция-замыкание. Важно учитывать, что замыкание происходит по ссылке, поэтому изменение переменной после декларирования замыкающей функции и до вызова функции-замыкания будет учтено. В примере ниже это отображено
```go 
func main() {
	num := 10
	fmt.Println("num before foo:", num) // 10

	foo := func() {
		num++
		fmt.Println("num in foo:", num)
	}
	num *= 10 // 100
	foo()
	fmt.Println("num after foo:", num) // 101
}
```
В данном примере получается что анонимная функция, сохраненная в `foo` замыкает переменные из внешней области видимости, поэтому `num` будет доступна.
Замыкания полезны, когда вам нужно создать функцию, которая использует состояние из её окружения. Это позволяет функциям сохранять доступ к переменным, даже если они были определены вне их собственной области видимости.

Если нужно, что бы преобразование над переменной внутри функции-замыкания не о повлияли на часть вне это функции, что стоит использовать аргументы для передачи значения в функцию
```go
func main() {
	workers := []func(){}
	i := 0
	for i < 5 {
		workers = append(
			workers, func() {
				fmt.Println("i:", i)
			})
		i++
	}
	for _, v := range workers {
		v()
	}
	/* Конечный вывод
	i: 5
	i: 5
	i: 5
	i: 5
	i: 5
	*/
}
```
В данном примере мы захватывает переменную `num`, но вызываем функции уже после всех преобразований.

Изменим код, что бы изменение переменной `i` нас не касались.
```go
func main() {
	workers := []func(){}
	i := 0
	for i < 5 {
		workers = append(
			workers, func(ii int) func() {
				return func() {
					fmt.Println("i:", ii)
				}
			}(i))
		i++
	}
	for _, v := range workers {
		v()
	}
	/* Конечный вывод
	i: 0
	i: 1
	i: 2
	i: 3
	i: 4
	*/
}
```
В этом случае мы `i` передаем как аргумент анонимной функции, внутри которой определена функция-замыкание, которая захватывает `ii`, и поскольку `ii` - аргумент, то в него передается передается копия значения `i` и поэтому изменения `i` не приведут к изменению в функции-замыкании

## Риски использования замыканий
**Утечка памяти**
Если замыкание ссылается на большую локальную переменную и это замыкание сохраняется длительное время, то это локальная переменная не будет освобождена, что может привести к утечке памяти
**Проблемы при параллелизме**
Если замыкание выполняется параллельно и ссылается на определенную переменную, то необходимо обеспечить, что данная ссылка является безопасной для параллелизма. Для этого можно использовать примитивы синхронизации (мьютексы).

