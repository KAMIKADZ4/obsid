Golang(Go) - компилируемый строго типизированный язык программирования, созданный в 2009 в Google инженерами Робом Пайком, Кеном Томпсоном (старожилы программирования приложившие руки к созданию UNIX, C, utf-8). 
Язык создавался с мотивом создания простого, но в тоже время производительного языка, под современные реалии компьютерных систем (Python - простой, но медленный, C++ - сложный и громоздкий) и создания высоконагруженные сетевых приложений. На Go написаны кстати такие приложения Docker и K8s.

Основные плюсы GO:
- Простота и читаемость кода: строгая типизации+минималистичный синтаксис
- Высокая производительность 
- Крут в конкурентности: из коробки лёгкие горутины и каналы для асинхронного программирования
- Быстрая компиляция

# Основные элементы программы 

## Пакеты `package`
Каждый файл начинается с объявления пакета. Если программа является исполняемой, то указывается пакет `main`
```go
package main
```
При написании собственный пакетов(библиотек) используется собственное название пакета, отличное от `main`
```go
package mypackage
```
Пакеты помогают разделять код на модули
## Импорт пакетов `import`
Для использования встроенных или сторонних пакетов их необходимо импортировать:
```go
// Вариант 1
import "fmt"
import "math"

// Вариант 2
import (
    "fmt"
    "math"
)
```
В Go можно добавить синоним, который заменит название импортированного пакета. 
```go
import (
    "fmt"
    myname "fmt" // с указанием синонима 
)

func main() {
    fmt.Println("Hi")
    myname.Println("Hello world!")
}
```

Компилятор будет ругаться на импортированный, но не используемый а коде пакет, но этого можно избежать 
```go
import ()
    _ "math" // компилятор не будет ругаться за неиспользование "math"
    "fmt"
)
```
Если в качестве указать `.`, то все импортированное добавится в текущий скоуп и можно будет ни использовать задание пакета при обращении к переменной. С такими импортами следует быть осторожнее
```go
import ()
    . "fmt"
)

func main() {
    Println("Hi")
}
```

Функция `init()` определяет логику при импортировании пакета. Как только пакет будет импортирован, то код в `init()` запустится.
https://habr.com/ru/articles/413563/ статья про импортирование пакета.

## Комментарии

```go
// Однострочный комментарий

/*
Многострочный
комментарий
*/
```

# Переменные и типы данных

Создание переменной в Golang:
```go
// объясление через ключевое слово var
// var <имя переменной> <тип> [= <значение>]
var myVar string
var yourVar int = 123

// краткое объявление (тип распознаётся автоматичски по значению)
newInteger := 100

// можно объявлять сразу несколько переменных одного типа
var a, b, c bool
x, y, z = 1, 2, 3
// и разных типов
var (
	name string = "Alex"
	age int = "18"
)
```

Имя переменной принято писать `camelCase`'ом и может содержать
- Латинские символы
- Цифры
- Символ подчеркивания (`_`)
Но название переменной начинаться с цифры не может

Если переменная объявлена, но не инициализирована, ей присваивается нулевое значение(zero value) по умолчанию:
```go
var x int       // x будет равно 0 (нулевое значение для int)
var y string    // y будет равно "" (пустая строка)
var z bool      // z будет равно false
```

## Перечень базовых типов данных
1. Числовые типы
	- Целые числа: `int`, `int8`, `int16`, `int32`, `int64`
		Нулевое значение: 0
	- Без знаковые целые числа: `uint`, `uint8`, `uint16`, `uint32`, `uint64`, `uintptr`
		Нулевое значение: 0
	- Дробное значения: `float32`, `float64`
		Нулевое значение: 0
	- Дробное значения: `complix64`, `complex128`
		Нулевое значение: (0+0i)
2. Строковый тип
	- `string`
		Нулевое значение: "" - пустая строка
3. Логический тип
	- `bool`
		Нулевое значение: false
4. Байтовые типы
	- `byte` (синоним `uint8`)
		Нулевое значение: 0
	- `rune` (синоним `int32`) - используется для представление Unicode символов
		Нулевое значение: 0

Важно подметить, что типы `int` и  `uint` занимают разный объем в зависимости от архитектуры системы. Эти типы данных платформо-зависимые типы.
- На 32-битных система занимают 4 байта (32 бита)
- На 64-битных система занимают 8 байта (64 бита)

Проверить размер типа int позволит этот код:
```go
package main

import (
    "fmt"
    "unsafe"
)

func main() {
    var x int
    fmt.Println("Size of int in bytes:", unsafe.Sizeof(x)) // Размер int в байтах
    fmt.Println("Size of int in bits:", unsafe.Sizeof(x)*8) // Размер int в битах
}
```

## Пакет builtin
Это специальный пакет, который не нужно импортировать и он содержит описание встроенных типов, функций и констант языка. В этой пакете есть такой тип как `any` который является синонимом `interface{}` - под это подходит любой тип (об этом подробнее в теме об интерфейсах)
https://pkg.go.dev/builtin

## Константы
Константы это постоянные значения, которые нельзя изменить
```go
// const [название] [тип данных] = [значение]
const StatusOk int = 200

const ( 
	StatusOk = 200 
	StatusNotFound = 404 
)
```
Для последовательных числовых констант следует использовать iota 
```go
const ( 
	zero = iota 
	one 
	two 
	three 
)
const ( 
	a = iota // 0 
	b = 42   // 42
	c = iota // 1
	d        // 2  
)
```

# Базовые математические операции
плюс минус равно делений остаток

# Условные конструкции

Пример кода c условными конструкциями
```go
if num < 1 {
	// code
} else if x < 10 {
	// code
} else {
	// code
}
```
В качестве условия должно быть строго выражение логического типа
```go
// нерабочие условия
if "hello" {
} 

if 1 {
}
```
Условие брать в круглые скобки можно, но не обязательно, даже не желательно и фигурные скобки нужны всегда

Конструкция `if` предполагает коротким объявление переменной
При этом переменная живет в рамках контекста условных конструкций
```go
if x := 10; x < 5 {
	fmt.Println("x =", x, "меньше 5")
} else if x > 8 {
	fmt.Println("Число болье 8")
	
} else {
	fmt.Println("Какое то иное число")
}
fmt.Print("Значение x:", x) // undefined: x


// удобно использовать для проверок в словарях
mapa = map[int]string{}
if _, ok := map[1]; ok {
	fmt.Println("Ключ 1 присутствует")
}
```

логические операторы
- && - and
- || - or
- ! - no

# Циклы

Базовый синтаксис для `for`
```go
for инициализация; условие; пост-действие {
    // тело цикла
}
```

Цикл без инициализации и пост действия, аналог `while`
```go
for условие{
	// тело цикла
}
```

Бесконечный цикл
```go
for {
	// тело цикла
}

```

Циклы `for range`
```go
for indexVar, valueVar := range collection {
	// loop body
}
```

## Итерирование по массивам
```go
numbers := [5]int{10, 20, 30, 40, 50}
for index, value := range numbers {
    fmt.Printf("Index: %d, Value: %d\n", index, value)
}
```
## Итерирование по срезам
```go
// slice
numbers := []int{10, 20, 30}
for index, value := range numbers {
    fmt.Printf("Index: %d, Value: %d\n", index, value)
}
```

## Итерирование по отображениям
```go
// map
ages := map[string]int{
    "Alice": 25,
    "Bob":   30,
}
for key, value := range ages {
    fmt.Printf("Key: %s, Value: %d\n", key, value)
}
```

## Итерирование по строкам
```go
str := "Привет"
for index, runeValue := range str {
    fmt.Printf("Index: %d, Rune: %c\n", index, runeValue)
}
```
итерация проходит по rune, а не по байтам

## Итерация по каналам
```go
ch := make(chan int)
go func() {
    ch <- 1
    ch <- 2
    ch <- 3
    close(ch)
}()
for value := range ch {
    fmt.Println(value)
}
```

## Break и continues
В циклах есть можно использовать `break` и `continue`
Метки в циклах можно использовать
```go
outerLoop:
for i := 0; i < 3; i++ {
    for j := 0; j < 3; j++ {
        if i == 1 && j == 1 {
            break outerLoop
            // или
            continue outerLoop
        }
        fmt.Printf("i: %d, j: %d\n", i, j)
    }
}
```
